# C++ 编程规范

## 常量

**尽可能使用const**

使用const常见的场景：

- 函数参数：传递引用时，如果函数不会修改传入参数, 该形参应声明为const。
- 成员函数：访问函数(如get函数)；不修改任何数据成员的函数；未调用非const函数、未返回数据成员的非const指针或引用的函数。
- 数据成员：如果数据成员在对象构造之后不再发生变化, 可将其定义为const。

## 初始化和类型转换

### 声明、定义与初始化

**禁止用memcpy、memset初始化非POD对象**

> POD 全称是“Plain Old Data”，是C++ 98标准(ISO/IEC 14882, first edition, 1998-09-01)中引入的一个概念， POD类型主要包括int, char, float，double，enumeration，void，指针等原始类型及其集合类型，不能使用封装和面对对象特性（如用户定义的构造/赋值/析构函数、基类、虚函数等）。

**避免构造函数做复杂的初始化，可以使用“init”函数**

以下情况可以使用init()函数来初始化：

- 需要提供初始化返回信息。
- 数据成员初始化可能抛异常。
- 数据成员初始化失败会造成该类对象初始化失败，引起不确定状态。
- 数据成员初始化依赖this指针：构造函数没结束，对象就没有构造出来，构造函数内不能使用this成员；
- 数据成员初始化需要调用虚函数。在构造函数和析构函数中调用虚函数，会导致未定义的行为。 

示例：

```c++
数据成员初始化可能抛异常：
class CPPRule
{
public:
    CPPRule():size_(0), res (null) {};	//仅进行值初始化
    long init(int size) 
    {
        //根据传入的参数初始化size_, 分配资源res
    }
private:
    int size_;
    ResourcePtr* res;
};
//使用方法：
CPPRule a;
a.init(100);
```

**初始化列表要严格按照成员声明顺序来初始化它们**

> 编译器会按照数据成员在类定义中声明的顺序进行初始化，而不是按照初始化列表中的顺序，如果打乱初始化列表的顺序实际上不起作用，但会造成阅读和理解上的混淆；特别是成员变量之间存在依赖关系时可能导致BUG。


**明确有外部依赖关系的全局与静态对象的初始化顺序**

> 如果全局对象A的成员变量有外部依赖，比如依赖另外一个全局变量B，在A的构造函数中访问B，隐含的规则就是B先于A初始化，然而全局与静态对象的初始化与析构顺序未有严格定义，无法确保B已经完成初始化，而每次生成可执行程序都可能发生变化，这类BUG难以定位。通常采用单件(Singleton)模式或者把有依赖关系的全局对象放在一个文件中定义来明确初始化顺序。同一个文件中，若全局对象a在全局对象b之前定义，则a一定会在b之前初始化；但是不同文件中的全局对象就没有固定的初始化顺序。可以在main()或 pthread_once() 内初始化一个运行期间不回收的指针。

### 类型转换

**使用C++风格的类型转换，不要使用C风格的类型转换**

- dynamic_cast：主要用于下行转换，dynamic_cast具有类型检查的功能。dynamic_cast有一定的开销，建议在调测代码中使用。
- static_cast：和C风格转换相似可做值的强制转换，或上行转换(把派生类的指针或引用转换成基类的指针或引用)。该转换经常用于消除多重继承带来的类型歧义，是相对安全的。下行转换(把基类的指针或引用转换成派生类的指针或引用)时，由于没有动态类型检查，所以不安全的，不提倡下行转换。
- reinterpret_cast：用于转换不相关的类型。reinterpret_cast强制编译器将某个类型对象的内存重新解释成另一种类型，相关代码可移植不好。建议对reinterpret_cast<> 的用法进行注释，有助于减少维护者在看到这种转换时的顾虑。
- const_cast：用于移除对象的 const属性，使对象变得可修改。

## 函数

### 内联函数

**内联函数(inline function)小于10行**

虚函数、递归函数不能被用来做内联函数。

**使用内联函数代替函数宏**

**内联函数应该放在头文件中声明，而且在函数前添加inline关键字**

> 内联函数的定义对编译器而言必须可见，以便在调用点将函数展开。放在头文件中可以保证对编译器可见，修改或者删除内联函数时，重新编译使用该头文件的所有源文件。

**内联函数的实现放在独立的文件**

除了最简单的成员存取函数外，其他较为复杂内联函数的实现放到独立的头文件中(建议使用.inl为扩展名)，在声明头文件的最后include。

### 函数参数

**入参尽量用const引用取代指针**

**消除未使用函数参数**

> 当实现接口时，有一些参数没有被引用是相当常见的。编译器会发现未使用的参数，并产生一个警告，有些组件甚至会认为这是一个错误。为避免发生如此情况，将未使用的参数使用/* 参数名 */ 语法将其注释掉。

```c++
//好的例子: 将localityHint参数名去掉，在注释中保留参数名以备参考和理解参数含义
pointer allocate(size_type numObjects, const void * /* localityHint */ = 0) 
{
    return static_cast<pointer>(mallocShared(numObjects * sizeof(T)));
}
```

**尽量少用缺省参数**

### 函数指针

**尽量少用函数指针**

> 不少代码中还是用函数指针来实现一些功能扩展（如封装），但函数指针难以理解和难以维护，建议使用C++中派生与继承的基本用法，少用函数指针。

## 类

### 类的设计

**类职责单一**

如果一个类有10个以上数据成员，类的职责可能过多。

**隐藏信息**

- 尽量减少全局和共享数据；
- 禁止成员函数返回成员可写的引用或者指针；
- 将数据成员设为私有的(struct除外)，并提供相关存取函数；
- 避免为每个类数据成员提供访问函数；
- 运行时多态，将内部实现(派生类提供)与对外接口(基类提供)分离。

**模块间对外接口类不要暴露私有和保护成员**

对外接口类暴露受保护或者私有成员则破坏了封装，一旦因为类的设计变更(增加，删除，修改内部成员)会导致关联组件或系统的代码重新编译，从而增加系统编译时间，也产生了二进制兼容问题，导致关联升级和打补丁。所以除非必要，不要在接口类中暴露私有和保护成员。

有如下几种做法：

- 使用纯虚类作为接口类，用实现类完成实现，使用者只看到接口类，这种做法缺点是：
  + 代码结构相对复杂。
  + 新增接口必须放在原有接口后面，不能改变原有接口的顺序。否则，因为虚函数表的原因，会导致客户代码重新编译。
- 接口类使用PIMPL模式(只有一个指向实现类指针的私有数据成员)，所有私有成员都封装在实现类中(实现类可以不暴露为头文件，直接放在实现文件中)。
  + 代码结构简单，容易理解。
  + 可以节省虚函数开销，但是有间接访问开销。
  + 修改实现不会导致客户代码重新编译。

```c++
class Interface
{
public:
    void function();
private:
    Implementation* impl_;
};

class Implementation
{
public:
    int i;
    int j;
};

void Interface:: function ()
{
    ++impl_->i;
}
```

**禁止类之间循环依赖**

循环依赖会导致系统耦合度大大增加，所以类之间禁止循环依赖。类A依赖类B，类B依赖类A。出现这种情况需要对类设计进行调整，引入类C：

- 升级：将关联业务提到类C，使类C依赖类A和类B，来消除循环依赖
- 降级：将关联业务提到类C，使类A和类B都依赖类C，来消除循环依赖。

**使用PIMPL模式，确保私有成员真正不可见**

### 构造、赋值和析构

**包含成员变量的类，须定义构造函数或者默认构造函数**

> 如果类有成员变量，没有定义构造函数，又没有定义默认构造函数，编译器将自动生成一个构造函数，但编译器生成的构造函数并不会对成员变量进行初始化，对象状态处于一种不确定性。

**为避免隐式转换，将单参数构造函数声明为explicit**

**包含资源管理的类应自定义拷贝构造函数、赋值操作符和析构函数**

如果不需要拷贝构造函数和赋值操作符，可以声明为private属性，让它们失效。

**让operator=返回*this的引用**

> 符合连续赋值的常见用法和习惯。

**在operator=中检查给自己赋值的情况**

```c++
class String
{
public:
    String(const char *value);      
    ~String();
    String& operator=(const String& rhs);
private:
    char *data;
};

//自赋值，合法
String a;
a=a; 
//不好的例子：忽略了给自己赋值的情况，导致访问野指针
String& String::operator=(const String& rhs)
{
    delete [] data;    //删除data

    //分配新内存，将rhs的值拷贝给它
    data = new char[strlen(rhs.data) + 1]; //rhs.data已经删除，变成野指针
    strcpy(data, rhs.data);

    return *this;     
}

//好的例子：检查给自己赋值的情况
String& String::operator=(const String& rhs)
{
    if(this != &rhs)
    {
        delete [] data;
        data = new char[strlen(rhs.data) + 1];
        strcpy(data, rhs.data);
    }
    return *this;     
}
```

**在拷贝构造函数、赋值操作符中对所有数据成员赋值**

**通过基类指针来执行删除操作时，基类的析构函数设为公有且虚的**

只有基类析构函数是虚拟的，才能保证派生类的析构函数被调用。

**避免在构造函数和析构函数中调用虚函数**

在构造函数和析构函数中调用虚函数，会导致未定义的行为。

**拷贝构造函数和赋值操作符的参数定义成const引用类型**

**在析构函数中集中释放资源**

### 继承

**用组合代替实现继承**

对继承而言，努力做到“是……一个的关系”，否则使用组合代替。

**虚函数绝对不使用缺省参数**

函数的缺省参数是在编译时静态绑定的。

你使用派生类中的虚函数时，使用的缺省参数值始终是基类中定义的。

**绝对不重定义继承而来的非虚函数**

**避免派生类中定义与基类同名但参数类型不同的函数**

基类中的符号会被派生类中的覆盖。

**派生类重定义的虚函数也要声明 virtual 关键字**

### 重载

**仅在输入类型不同、功能相同时重载函数**

**使用重载以避免隐式类型转换**

## 作用域、模板和C++其他特性

### 作用域

**不要在头文件中或者#include之前使用using指示符**

**尽量少使用嵌套类**

不要通过嵌套类来进行命名分组，应该使用名字空间。

**使用静态成员函数或名字空间内的非成员函数，避免使用全局函数**

**避免class类型的全局变量，尽量用单件模式**

> 静态生存周期的对象, 包括全局变量, 静态变量, 静态类成员变量, 以及函数静态变量, 都必须是原生数据类型 (POD : Plain Old Data)。

静态变量的构造函数, 析构函数以及初始化操作的调用顺序在C++标准中未明确定义,从而导致难以发现的 bug。比如作用域结束时，某个静态变量已经被析构了，但其他代码还试图访问该变量，导致系统崩溃。

### 模板

模板可以衍生出一系列的类和函数，这是一种形式的代码复用。但要注意，这种形式的复用是源代码级而不是目标代码级的。也就是说，对模板的每一次实例化都会产生一份新的源代码。与此相反，继承允许复用基类的大部分目标代码。

滥用模板会造成三个后果：第一，代码规模的过度膨胀；第二，当修改模板时，很难预料是否会对原先正常工作的代码造成不良影响；第三，很难确保模板所有可能的合法实例化都能正常工作。所以模板的使用要仔细且有节制。

### 其他

**不要在extern "C"内部使用#include包含其他头文件**

> 在C++代码中调用C的库文件，需要用extern "C"来告诉编译器：这是一个用C写成的库文件，请用C的方式来链接它们。

严格的讲，只应该把函数、变量以及函数类型这三种对象放置于extern "C"的内部。

**使用sizeof(变量)而不是sizeof(类型)**

使用 sizeof(varname)，当代码中变量类型改变时会自动更新。

对数组来说，sizeof(数组变量) 并不一定是元素的个数，元素个数是sizeof(数组变量)/sizeof(数组变量[0])。

**避免使用友元**

> 友元扩大了 (但没有打破) 类的封装边界。友元会导致类间强耦合，打破封装，暴露出具体实现，从而使友元和类的实现紧耦合；友元不可继承，降低可继承性。

例外：某些情况下, 相对于将类成员声明为public, 使用友元是更好的选择, 尤其是你只允许另一个类访问该类的私有成员时。

## 资源分配和释放

### 规则

**明确产品动态内存的申请与释放原则**

- 对象在退出其作用域时，就应该立即被释放，而且要做到：谁申请，谁释放；
- 函数内分配的内存， 函数退出之前要释放，避免跨函数释放；
- 类中数据成员的内存，在析构函数中确认并释放；
- 如果程序分支很多或内存资源的分配与释放不在同一个地方，要考虑使用RAII等资源跟踪管理技术。

**不要返回局部对象的指针**

**不要强制关闭线程**

> 线程被强制关闭，导致线程内部资源泄漏。用事件或信号量通知线程，确保线程调用自身的退出函数。线程死锁需要强制关闭的情况除外。

## 异常和错误处理

### 异常

**减少不必要的异常**

> 异常对编码技能要求更高，使用中容易出错，首先从安全性角度考虑，尽量少用或者不用异常。

相比返回错误，异常的优点：

- 异常可以集中捕捉，错误检测与算法处理相分离，算法逻辑更清晰；而返回错误在每个返回点都要进行检测与错误处理，代码逻辑分散。
- 异常的约束更强，用户不能忽略抛出的异常，否则程序默认会被终止，而返回错误则可能被忽略。

异常的缺点也很明显：

- 必须检查所有调用点是否可能抛出异常，在抛出后必须正确处理状态和资源变量等，否则可能导致对象状态不正确或者资源泄露等。例如：如果f()依次调用了g()和h()，h抛出被f捕获的异常，g就要当心了，避免资源泄露。
- 必须清楚可能抛出的所有异常，并在合适的地方捕捉，如果遗漏通常会导致程序被终止。
- 使用异常很难评估程序的控制流，代码很难调试。
- 目标文件变大，编译时间延长，性能下降。

若对异常缺乏充分理解，可能会在不恰当的时候抛出异常, 或在不安全的地方从异常中恢复。
适用异常的几个场景：

- 出现“不应该出现的”失败，且不能被忽略必须处理，比如分配内存失败。
- 上层应用决定如何处理在底层嵌套函数中 “不可能出现的” 失败。
- 错误码难以通过函数的返回值或参数返回，比如流。
- 许多第三方C++库使用异常，必须在系统边界与第三方C++库结合处使用异常便于跟这些库集成。
- 在测试框架中使用异常很方便。

**构造和析构函数不能抛出异常**

> 如果构造和析构函数执行失败则无法安全地撤销和回滚，故这些函数不能向外抛出异常。
> 为了降低复杂性，建议在这类函数中实现最简单的逻辑。

**通过传值的方式抛出，通过引用的方式捕获**

> 抛出异常时，如果抛出指针，谁释放指针就成为问题。捕捉时如果是传值，会存在拷贝，拷贝可能不成功(比如异常是由于内存耗尽造成的)，而且拷贝得不到派生类对象，因为在拷贝时，派生类对象会被切片成为基类对象。

**确保抛出的异常一定能被捕捉到**

> 异常未被捕捉到，系统的默认行为是终止程序运行，所以要确保程序产生的异常都能被捕捉。

**确保异常发生后资源不泄漏**

**独立编译模块或子系统的外部接口禁止抛异常**

## 标准库

**避免使用 auto_ptr**

> auto_ptr 具有一个隐式所有权转移行为，不建议使用。

**仅使用 shared_ptr 和 unique_ptr 管理单个对象**

> 这些智能指针在销毁对象时使用的是 delete 而不是 delete []。

**如果涉及循环引用，使用weak_ptr解开循环**

**使用 make_shared 代替 new 生成 shared_ptr**

**对于同一个对象一旦使用shared_ptr，后续就要处处使用shared_ptr**

> 混用原生指针和shared_ptr容易导致问题：使用悬空指针和重复释放。

**对于返回自身的shared_ptr指针的对象，要从enable_shared_from_this类派生**

## 程序效率

### C++语言特性的性能分级

C++语言特性的性能描述采用FREE/CHEAP/EXPENSIVE的分级。

| C++语言特性 | 性能分级        | 备注                                                         |
| ----------- | --------------- | ------------------------------------------------------------ |
| 封装        | FREE            | class和C的struct在使用空间上是相同的，class中的成员函数的时间开销也和C等效代码是一致的。 |
| 多态        | FREE            | 含有虚函数的class在空间上需要增加虚表指针(4字节)，在虚函数的执行上需要间接寻址的开销。虽然有微量开销，但等同于C等效代码。 |
| 名字空间    | FREE            | Namespace会带来符号名字符串长度的增加，但C等效代码也需要增加前缀字符串(比如模块名)。 |
| 隐含内联    | FREE            | 没有函数调用的开销，没有指令跳转的顺序执行能让编译器进行更好的优化，但会增加程序大小。 |
| 重载        | FREE            | 等效类成员函数的开销                                         |
| 构造和析构  | FREE            | 等效类成员函数的开销                                         |
| 引用        | FREE            | 等效或优于指针的使用，引用可以避免指针的间接寻址开销。       |
| 模板        | FREE~EXPENSIVE  | 模板具有静态多态的优点，部分逻辑提前到编译阶段以提升性能；但会导致代码膨胀，程序尺寸增大。 |
| RTTI        | CHEAP~EXPENSIVE | 执行时间有一定耗时，gcc/VC中dynamic_cast的开销小于10倍函数调用，程序尺寸增大。 |
| 异常        | EXPENSIVE       | 异常捕捉很耗时，其包括栈展开等操作，gcc/VC中异常处理开销大于300倍函数调用。 |
| STL         | CHEAP~EXPENSIVE | STL提供线性(list)、对数级(map)和常量级(hash_map)不同性能的容器，建议根据应用实际需求选用。 |

### C++语言性能优化指导

**先测量再优化，避免不成熟的优化**

**选用合适的算法和数据结构**

**在构造函数中用初始化代替赋值**

> 通过成员初始化列表来进行初始化总是合法的，效率也高于在构造函数体内赋值。

**对象参数尽量传递引用(优先)或指针而不是传值**

**优先采用前置自增/自减**

**简单访问方法尽量采用内联函数**

**要审视标准库的性能规格**

> std::string是个巨大类，若使用不当(比如大量的+操作)会导致性能迅速下降；std::list<T>::size()在某些实现版本中是线性的，所以在if(myList.size()==0)时可以考虑用if(myList.empty())替换；标准输入输出是性能瓶颈，如果不混用C++和C的标准输入输出库，可以考虑关掉同步：std::ios_base::sync_with_stdio(false)。

**用对象池重载动态内存管理器**

> 系统调用new和delete涉及到系统调用等复杂处理，时间和空间开销都较大，对于DOPRA的内存申请机制也有类似的情况。建议对于特定类的申请和释放，采用自定义的对象池机制管理该对象的申请和释放，而不用操作系统或DOPRA的内存管理机制。对象池的大小需要预先确定或是采用类似std::vector.resize()的方法可以动态增长。

**注意大尺寸数组的初始化效率**

> 我们常这么初始化数组:
> `char szAccount[MAX_ACCOUNT_LEN] = {0};`//数组大小16
> 对于字符串确保有结束符即可，故要初始化也应该用“szAccount[0] = 0;”替换之，当然在非关键路径，上述的一行代码完成初始化代码更简洁，也能够被接受。
> `char chTempBuff[MAX_MSG_LEN]    = {0};`//数组大小为40K
> 而对于如此大的一块内存清0，应该用memset等库函数替代之。编译器不优化情况下，对于{0}的初始化，通常是一个字节逐一赋值为0，而memset在64位平台下很可能是一次8个字节。故当数组大于10个字节时，两者的性能差距在2~8倍，根据数组大小而定。
> 特别是生成或者删除大尺寸的对象数组，每个数组成员的构造函数或析构函数度要被调用一次，花费的时间更多。

**避免在函数内部的小块内存分配**

> 例子 某函数内部，根据消息长度分配内存，然后做相关操作，函数退出前释放内存，如下：
> `char *pMsg = new char[msgLen];`
> 其实pMsg的生命周期仅仅在函数内，它所指向的内存其实应该是一个临时变量，如果我们能够预测其最大长度远小于线程栈空间，比如最大几十K，或者只有几十字节，那么就应该声明一个足够大的临时数组，如下：
> `assert(msgLen <= MAX_MSG_LEN);`//某些情况下可能需要if检测，而断言检测可能不充分。
> `char chMsg[MAX_MSG_LEN];`//不会有失败和释放的处理，效率也完全不在一个数量级

## 并发

**锁的职责单一**

> 每个锁只锁一个唯一共享资源；这样，才能保证锁应用的单一，也能更好的确保加锁的范围尽量小。
> 对于共享全局资源，应该根据实际需要，每类或每个资源，有一把锁。这样，这把锁只锁对这个资源访问的代码，通常这样的代码都会是比较简单的资源操作代码，不会是复杂的函数调用等。相反，如果我们对几类或几个资源共用一把锁。这把锁的责任范围就大了，使用复杂，很难理清锁之间的关系(有没有释放锁，或者锁之间的嵌套加锁等)，容易导致死锁问题。

**锁范围尽量小，只锁对应资源操作代码**

> 使用锁时，尽量减少锁的使用范围。我们使用锁，为了方便，会大范围的加锁，如：直接锁几个函数调用。这种使用，一方面会导致多线程执行效率的低下，容易变成串行执行；另一方面，容易出现锁未释放，或者锁的代码中再加锁的场景，最后导致死锁。

所以，对锁操作的最好办法，就是只锁简单资源操作代码。对应资源访问完后，马上释放锁。尽量在函数内部靠近资源操作的地方加锁而不是靠近线程、函数外部加锁。

**进程间通讯，使用自己保证互斥的数据库系统、共享内存，或socket消息机制；尽量避免使用文件等进程无法管理的资源**

> 由于文件在不同进程间访问，无法保证互斥。当然，可以在进程间加进程锁，但只受限于我们能加锁的进程，对于第三方进程等无法保证。这样，当多个进程同时对文件进行写操作时，将会导致文件数据破坏，或文件写失败等问题。
> 当数据库系统本身的访问接口带有互斥机制，当多个进程同时访问时，可以保证数据库数据的完整。
> 共享内存，只限制于使用共享内存的几个进程，需要我们对这些访问共享内存的进程加锁。但由于共享内存，第三方进程等无法访问，这也能比较好的保护数据，避免文件系统存在的问题。
> socket消息机制，由操作系统socket通讯机制保证互斥，在多个进程间，通过消息来保证数据的互斥。进程的消息都是操作系统转发而来的独立数据，属于进程私有数据，不存在进程间并行访问的问题。

**锁中避免调用函数；如果必须调用函数，务必保证不会造成死锁**

锁中调用函数，也会把对资源操作的代码扩大化，不利于并行效率。更主要的是，这种操作，由于加锁的范围变大，引起死锁的可能就增大。

**锁中避免使用跳转语句**

## 风格

**类的声明按照一定的次序进行，关键字不缩进**

类的声明按照一定的次序和规范进行。建议的次序如下：

- 按照存取控制特性段排序：public、protected、private，如果没有可以忽略。这个排序是让声明的时候使用者首先看到最关心的特性(对外接口)。
- 在每一段中按照如下顺序声明:
 + typedefs和enums；
 + 常量；
 + 构造函数；
 + 析构函数；
 + 成员函数，含静态成员函数；
 + 数据成员，含静态数据成员。

**构造函数初始化列表在同一行或按4格缩进并排几行**

## 可移植性

**不直接使用C++的基本数据类型，不要假定其存储尺寸长度**

**避免指针截断**

指针截断是从32位移植到64位系统时，经常会碰到的问题。

```c++
int *i = &int_val;
short *w = (short*)((int)i + 2);
```

上面的代码在32位环境下运行是没有问题的，但在64位环境下，发生了地址截断：无法把64位长的数据接到32位的数据空间里面。

上面的代码中可以使用intptr_t类型解决：

```c++
int *i = &int_val;
short *w = (short*)((intptr_t)i + 2);
```

**注意数据类型对齐问题**

需要对结构对齐加以留心，尤其是对于存储在磁盘上的结构体。

在64位系统中，任何拥有int64_t/uint64_t成员的类/结构体将默认被处理为8字节对齐。如果32位和64 位代码共用磁盘上的结构体，需要确保两种体系结构下的结构体的一致对齐。
另外，大多数编译器提供了调整结构体对齐的方案：

gcc 中可使用__attribute__((packed))，MSVC 提供了#pragma pack()和__declspec(align())。

由于各个平台和编译器的不同，所以在不同编译器与平台移植代码时，一定要特别关注编译器关于对齐的参数设置与默认值。因为字节对齐不仅影响性能，而且会导致一些不可预知的问题。

**避免无符号数与有符号数的转换**

不同的国际标准(ANSI C/ISO C++等)对隐式转换有符号和无符号类型的规则不同，有可能导致不同的执行结果。

```c++
unsigned short usNumber = xxx;
long lNum = usNumber;
```
将unsigned short赋值给long需要经过两次类型转换，ANSI标准中没有规定多次类型转换的顺序。
大多数编译器(例如VC)在高位优先填充0，按照下面的顺序进行转换：
	lNum = (long) (unsigned long) usNumber;
个别编译器(例如BSD的一些编译器)在高位优先填充1，即使用下面的顺序进行转换：
	lNum = (long) (signed short) usNumber;
如果是后一种转换顺序，并且正好usNumber的高位为1，则首先被转换成一个负数的long，接着转换成unsigned long时就成了很大的数。
usNumber永远不可能为负数，没有必要使用signed修饰。
修改办法是定义lNum的类型为unsigned long，并更改名字为ulNum：
unsigned short usNumber = xxx;
unsigned long ulNum = usNumber;
尽量避免无符号数与有符号数的转换，特别是长度不同数值的类型转换。请首先考虑设计上是否需要这种转换。

**区分sizeof(void *)和sizeof(int)**

64位下sizeof(void *) != sizeof(int)，而在32位下是相同的。
如果需要一个指针大小的整数请使用intptr_t。

**编译器，操作系统相关的代码独立出来**

**创建64 位常量时使用LL 或ULL 作为后缀**
