## 历史观点

Intel 系列有好几个名字，包括 IA32，也就是“Intel 32位体系结构”，以及新的 Intel64，即IA32的64位扩展，我们也称为x86-64，我们最常用的名字是"x86"，用它指代整个系列，也反应了知道 i486 处理器命名的惯例。

AMD 生产的是与 Intel 处理器兼容的处理器，因此也可以叫 x86 系列。

x86 中加入了很多处理浮点数向量的格式和指令。增加这些特性提高了多媒体应用的性能。虽然这种1985年代的微处理器几乎已经没有了，但 GCC 为 32 位执行的默认调用，仍然假设是为 i386 机器产生代码。只有给出指定的命令行选项，或是为 64 位执行进行编译时，编译器才会使用更新一些的扩展功能。

## 程序编码

gcc 命令调用了一系列程序，将源代码转化为可执行代码。**C预处理器**用于扩展源代码，**编译器**用于将源代码转化为汇编代码，**汇编器**将汇编代码转化成二进制目标代码，**链接器**将目标代码与相关库代码合并生成最终的可执行代码。

### 关于格式的注解

在汇编文件中，所有以'.'开头的行都是指导汇编器和链接器的命令。

> ATT 与 Intel 汇编代码格式，前者是gcc、objdump和其他一些工具的默认输出格式。

## 数据格式

由于是从16位体系结构扩展到32位的，Intel 用术语“字”表示16位数据类型。因此，32位数称为“双字”，64位数称为“四字”。

## 访问信息

### 数据传送指令

MOV 类中的指令将源操作数的值复制到目的操作数中。原操作数指定的值是一个立即数，存储在寄存器或存储器中。目的操作数指定一个位置，要么是一个寄存器，要么是一个存储器地址（不能是立即数）。

> IA32 加了一条限制，传送指令的两个操作数不能都指向存储器位置；将一个存储器位置的值复制到另一个存储器位置需要两条指令，第一条指令将源值加载到寄存器中，第二条将该寄存器中的值写入目的位置。

## 算术和逻辑操作

### 加载有效地址

`leal S, D` 它的源操作数是一个有效的地址，目的操作数必须是一个寄存器。

### 一元操作和二元操作

**一元操**作只有一个操作数，既是源又是目的，这个操作数可以是一个寄存器，也可以是一个存储器位置。

**二元操作**，第二个操作数既是源又是目的。第一个操作数可以是立即数·寄存器或是存储器位置。第二个操作数可以是寄存器或是存储器位置。