## 信息存储

每台计算机都有一个字长，指明整数和指针的标称大小。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。

### 数据大小

指针和"长"整数使用机器的全字长。

| C 声明        | 32位机器 | 64位机器 |
| ------------- | -------- | -------- |
| char          | 1        | 1        |
| short int     | 2        | 2        |
| int           | 4        | 4        |
| long int      | 4        | 8        |
| long long int | 8        | 8        |
| char *        | 4        | 8        |
| float         | 4        | 4        |
| double        | 8        | 8        |

### 寻址和字节顺序

- 小端法：最低有效字节在前
- 大端法：最高有效字节在前

字节序变得可见的情况：

1. 网络编程
2. 检查机器级程序
3. 编写规避正常的类型系统的程序时

### 表示字符串

文本数据比二进制数据具有更强的平台独立性。

### C语言中的移位运算

- 左移
- 逻辑右移（左端补0）
- 算术右移（左端补最高有效位）

C语言中对于无符号数，右移必须是逻辑的；对于有符号数，逻辑和算术右移都可以，但一般采用算术右移。

## 整数表示

long 是唯一一个取值范围与机器相关的整数类型。

### 无符号数编码

无符号数的取值范围：$0\sim2^w -1$

### 补码编码

最常见的有符号数的计算机表示方式是补码形式。

有符号数的取值范围：$-2^{w-1}\sim2^{w-1} - 1$

补码表示的范围是不对称的，最小负数的绝对值 = 最大非负数 + 1；一半的位模式表示负数，一半的位模式表示非负数，因为0是非负数，也就意味着能表示的正数比负数少一个。

C库中的文件 <limits.h> 定义了一组常量，来限定编译器运行的这台机器的不同整形数据类型的取值范围。

有符号数的其他表示：反码，原码。

### 有符号数和无符号数之间的转换

**有符号数转无符号数**

$$
    T2U_w(x) = 
    \begin{cases}
    x + 2^w, &\text x < 0 \\
    x, &\text x \geq 0
    \end{cases}
$$

> x 为无符号数的值，w 表示无符号数有多少位组成

**无符号数转有符号数**

$$
    U2T_w(x) = 
    \begin{cases}
    u, &\text u < 2^{w-1} \\
    u - 2^w, &\text u \geq 2^{w-1}
    \end{cases}
$$

### C语言中的有符号数与无符号数

通常大多数数字默认为有符号数，要创建无符号常量，必须加上后缀字符'u'。

当执行一个运算时，如果它的运算数一个是有符号数而另一个是无符号数，那么C语言会隐式的将有符号数转换为无符号数，并假设这两个数都是非负的。

### 扩展一个数据的位表示

将一个无符号数转换成一个更大的数据类型，只需要简单地在高位加0，这种运算叫**零扩展**；将一个以补码表示的有符号数转换为一个更大的数据类型可以执行**符号扩展**，添加最高有效位的副本。

在c语言中将 short 转换成 unsigned 时，我们先扩展数据位，再进行有符号和无符号转换。

### 截断数字

截断数字（将 int 转换成 short）可能会改变它的值 — 溢出的一种样式。

### 关于有符号数与无符号数的建议

无符号数到有符号数的隐式转换会导致很多错误和漏动工，所以通常情况下避免使用无符号数，除非把字仅仅看作是位的集合而没任何数字的意义。

## 整数运算

### 无符号加法

无符号运算可以被视为一种模运算形式。

### 补码加法

正溢出，正常，负溢出

### 补码乘法

对于无符号和补码乘法来说，乘法运算的位级表示都是一样的。这表明机器可以用一种乘法指令来进行有符号和无符号整数的乘法。

```c
//判断整数乘法是否溢出
int tumult_ok(int x, int y)
{
    //（long long）强制类型转换至关重要，不这样就会用32位来计算乘积，然后
    //再符号扩展到64位
	long long pll = (long long)x * y;
    // 溢出时溢出的位会被截断，就和强转成32位在位级表示时一致的
	return pll == (int)pll;
}
```

### 乘以常数

在大多数机器上，整数乘法指令相当慢，需要10个或更多的时钟周期，而其他整数运算只需要一个时钟周期。因此，编译器会使用一项重要的优化，试着用位移和加法的组合来代替乘以某个常数因子的乘法。

`(x<<n)+(x<<n-1)+...+(x<<m)`

`(x<<n+1)-(x<<m)`

### 除以2的幂

在大多数机器上，整数除法比整数乘法更慢。除以2的幂可以用移位运算来实现。但同乘法不同，这种方法不能推广到除以任意常数。

`(x < 0 ? (x + (1<<k) -1) : x) >> k`

## 浮点数

### IEEE 浮点表示

$$V=(-1)^s\times M \times 2^E$$

- 符号 s 决定这个数是正数还是负数
- 尾数 M 是一个二进制小数
- 阶码 E 的作用是对浮点数加权

将浮点数的位表示划分为三个字段，分别对上面三个值进行编码。

- 一个单独的符号位单独编码
- k 位的阶码字段 exp 对 E 进行编码
- n 位的小数字段 frac 对 M 进行编码

![标准浮点格式](http://oxi9u6h56.bkt.clouddn.com/blog/xxdbshcl/bzfdgs.png-sy.png)

给定了位表示，根据 exp 的值，被编码的值可分为三种情况：

- 规格化的值
- 非规格化的值
- 特殊值

**规格化的值**

当 exp 的位模式不是全0或全1时，都属于这类情况
`E=e-Bias` `M=1+f`
e 是阶码的的值，Bias 等于 $2^{k-1}-1$，f 是小数字段的值

**非规格化的值**

当 exp 的位表示全是0时，就属于这类情况
`E=1-Bias` `M=f`

非规格化数的两个作用

1. 提供了1种表示数值0的方法
2. 表示那些非常接近0.0的值

**特殊值**

这种情况是当 exp 的位表示全为1时出现的，frac 的值为0时得到值表示无穷大， s=0 时表示正无穷，s=1 时表示负无穷。当我们把非常大的两个数相乘，或除以零时，无穷能表示溢出的结果。当 frac 非零时，结果值称为 `NaN` 表示“不是一个数”，一些运算的结果不能是实数或无穷，就用这个值表示，比如对负数开根号。

### 舍入

因为表示方法限制了浮点数的范围和精度，浮点运算只能近似地表示实数运算。

IEEE 浮点格式定义了四种不同的舍入方式，默认的方法是找到最接近的匹配（向偶数舍入），而其他三种可用于计算上界或下界。

当被舍入值是中间值时，向偶数舍入采取的方法是：将数字向上或向下舍入。使得结果的**最低有效数字**是偶数。

例如：1.5 和 2.5 舍入后的结果都为 2。

其他三种舍入方式：向零舍入，向下舍入，向上舍入。

向偶数舍入法能够运用于二进制小数。我们将最低有效位的值0认为是偶数，值1认为是奇数。

### 浮点运算

浮点加法和乘法满足单调性，这是无符号数或补码不具备的。

> 如果 $a \geq b$，那么对于任何a、b和x的值，除了NaN，都有$a+x \geq b+x$

### c 语言中的浮点数

当int、float和double格式之间进行类型转换时，程序改变数值和位模式的原则如下：

- 从int转float，数字不会溢出，但值可能会被舍入
- 从int或float转double，能够保留精确的数值
- 从double转float，值可能被舍入或溢出成为无穷大
- float或double转int，值将向零舍入，也可能产生溢出，溢出时，与Intel兼容的微处理器指定0x80000000为*整数不确定值*。一个浮点数到整数的转换，如果不能位浮点数找到一个合理的整数近似值，就会产生这个值

## 小结

相同长度的无符号数和有符号数进行强制类型转换时，大多少c语言实现遵循的原则是位模式不变。

c语言实现的有限整数运算和真实的整数运算相比，有一些特殊的属性。例如，由于溢出，表达式 `x*x` 能够得出负数。但是，无符号数和补码的运算都满足整数运算的很多属性，包括结合律、交换律和分配律。浮点运算只满足交换律。
