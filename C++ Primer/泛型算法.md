## 定制操作

很多标准算法都会比较两个输入序列中的元素。默认情况下使用元素类型的 < 或 == 运算符完成。标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符。

### 向算法传递函数

**谓词**

谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法使用的谓词分为两类：一元谓词（只接受单一参数）和二元谓词（接受两个参数）。

### lambda 表达式

一个 lambda 表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。lambda 表达式可定义在函数内部。

```c++
[capture list] (parameter list) -> return type {function body}
```

capture list 是一个 lambda 所在函数中定义的局部变量的列表（通常为空）。

我们可以忽略参数列表和返回类型，但必须包含捕获列表和函数体。如果忽略返回类型，lambda 表达式根据函数体中的代码推断出返回类型。

捕获列表为空表示 lambda 表达式不使用它所在函数中的任何局部变量。

**向 lambda 传递参数**

与普通函数不同，lambda 不能有默认参数。

一个 lambda 可以使用定义在当前函数之外的名字。

### lambda 捕获和返回

当定义一个 lambda 时，编译器生成一个与 lambda 对应的新的（未命名）类类型，在传递一个 lambda 表达式时就会生成这种类型的未命名对象。

默认情况下，从 lambda 生成的类都包含一个对应该 lambda 所捕获的变量的数据成员，这些数据成员在对象被创建时初始化了。

如果函数返回一个 lambda 表达式，此lambda不能包含引用捕获。因为局部变量会在函数返回时消失。

> 避免捕获指针或引用，因为这些类型在捕获时和使用的值可能不同。

**隐式捕获**

让编译器根据 lambda 体中的代码来推断我们要使用哪些变量。

**指定返回类型**

默认情况下，如果一个 lambda 体包含 return 之外的任何语句，则编译器假定此 lambda 返回 void。**这种情况下要返回值，必须指定返回类型**。

### 参数绑定

解决一元谓词需要绑定一个实参的问题。

**标准库bind函数**

bind 是一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。

auto newCallable = std::bind(callable, argList);

当用户调用 newCallable 时，newCallable 会调用 callable 并传递给他 argList 中的参数。

argList 中的参数可能包含形如_n的名字，其中n是一个整数。这些参数是“占位符”，它们占据了传递给 newCallable 的参数的“位置”；_1 表示 newCallable 的第1个参数。

**使用 placeholders 名字**

名字 _n 都是定义在名为 std::placeholders 命名空间下。

**绑定引用参数**

默认情况下，bind 的那些不是占位符的参数被拷贝到 bind 返回的可调用对象中。对有些绑定的参数我们希望以引用方式传递，或是绑定参数的类型无法拷贝（如：ostream），此时需要使用标准库的 `ref` 和 `cref` 函数，后者表示 const 引用。

## 再探迭代器

### 插入迭代器

插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。

- back_inserter 创建一个使用 push_back 的迭代器
- front_inserter 创建一个使用 push_front 的迭代器
- inserter 该函数接受两个参数，第二个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。

### iostream 迭代器

### 反向迭代器

rbegin()，rend()，crbegin()，crend()

反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。

将反向迭代器转换为普通迭代器，可通过其成员函数 base 完成。

## 泛型算法结构

### 5类迭代器

**迭代器类别**

- 输入迭代器
- 输出迭代器
- 前向迭代器
- 双向迭代器
- 随机访问迭代器

## 特定容器算法

链表类型 list 和 forward_list 定义了几个成员函数形式的算法。

通用版本的 sort 算法要求随机访问迭代器，因此不能用于 list 和 forword_list，因为这两种类型分别提供双向迭代器和前向迭代器。

除 sort 外，链表版本的算法性能比对应版本的版本好的多。
